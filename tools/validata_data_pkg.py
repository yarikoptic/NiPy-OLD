#!/usr/bin/env python
''' Re-create and check data packages

The script expects to be run something like this:

<script_name> <pkg_dir>

where <pkg_dir> is a directory containing the tree for a nipy data
package.  <pkg_dir> will therefore contain a ``setup.py`` file, and will
contain one and only one data sub-directory <datadir> with at least a
``config.ini`` file, giving the package version.

The script runs ``python setup.py sdist`` on the package to check the
sdist mechanism and generate the archive.  It then unpacks the generated
archive in a temporary directory, installs it with ``python setup.py
install`` in that same temporary directory, then checks that NIPY can
read the package.
'''

from __future__ import with_statement

import os
from os.path import join as pjoin
import re
import subprocess
from functools import partial
from glob import glob
import zipfile
import shutil

import argparse

from nipy.utils import InTemporaryDirectory, make_datasource

caller = partial(subprocess.check_call, shell=True)

parser = argparse.ArgumentParser()
parser.add_argument('pkg_dirs', nargs='+')

pkg_re = re.compile(r"nipy-(\w+)-[\d\w.]+")

def extract_zip(zipobj, todir=''):
    for name in zipobj.namelist():
        out_file = pjoin(todir, name)
        pth, fname = os.path.split(out_file)
        try: # create directory tree on the fly
            os.makedirs(pth)
        except OSError:
            pass
        with open(out_file, 'wb') as f:
            f.write(zipobj.read(name))


def check_pkg_dir(pkg_dir, clobber=False):
    # check there are no dist files
    dist_dir = pjoin(pkg_dir, 'dist')
    if os.path.isdir(dist_dir):
        if clobber:
            shutil.rmtree(dist_dir)
        else:
            raise OSError('Existing dist directory %s, '
                          'consider clobber=True' % dist_dir)
    # Run sdist from directory 
    pwd = os.getcwd()
    try:
        os.chdir(pkg_dir)
        caller('python setup.py sdist --formats=zip')
    finally:
        os.chdir(pwd)
    # Collect created archive
    archives = glob(pjoin(dist_dir, '*.zip'))
    if not archives:
        raise OSError('No archives in %s generated by sdist?' %
                      dist_dir)
    archive = archives[0]
    # extract package name from archive
    pth, fname = os.path.split(archive)
    fname, ext = os.path.splitext(fname)
    pkg_match = pkg_re.search(fname)
    if not pkg_match:
        raise OSError('Could not get package name from %s' % archive)
    pkg_name = pkg_match.groups()[0]
    archive = os.path.abspath(archives[0])
    with InTemporaryDirectory() as tmpdir:
        zipf = zipfile.ZipFile(archive)
        extract_zip(zipf)
        out_dirs = glob('*')
        if not out_dirs:
            raise OSError('No directory created by package unpack')
        if len(out_dirs) > 1:
            raise OSError('Expecting only one directory, got %s' %
                          ';'.join(out_dirs))
        os.chdir(out_dirs[0])
        caller('python setup.py install --prefix=%s' % tmpdir)
        # check that nipy finds the directory and initializes it correctly
        os.environ['NIPY_DATA_PATH'] = tmpdir
        repo = make_datasource('share', 'nipy', 'nipy', pkg_name)
    return archive


def main():
    # parse the command line
    args = parser.parse_args()
    # check the packages
    archives = []
    for pkg_dir in args.pkg_dirs:
        archives.append(check_pkg_dir(pkg_dir, clobber=True))
    print 'Checked archives'
    print archives


if __name__ == '__main__':
    main()
    
